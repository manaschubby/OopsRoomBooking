package com.kanchan.RoomBooking.Bookings;import com.kanchan.RoomBooking.Error;import com.kanchan.RoomBooking.Rooms.RoomModel;import com.kanchan.RoomBooking.Rooms.RoomRepository;import com.kanchan.RoomBooking.Users.UserModel;import com.kanchan.RoomBooking.Users.UserRepository;import com.kanchan.RoomBooking.Users.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.ResponseEntity;import org.springframework.stereotype.Service;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.*;@Servicepublic class BookingService {    @Autowired    private BookingRepository bookingRepository;    @Autowired    private RoomRepository roomRepository;    @Autowired    private UserRepository userRepository;    public BookingService(BookingRepository bookingRepository, RoomRepository roomRepository, UserRepository userRepository) {        this.bookingRepository = bookingRepository;        this.roomRepository = roomRepository;        this.userRepository = userRepository;    }    public ResponseEntity<Object> addBooking(int userId, int roomId, Date dateOfBooking, Date timeFrom, Date timeTo, String purpose, boolean dateError) {        // Check if user exists        UserModel user = userRepository.findById(userId).orElse(null);        if (user == null) {            return ResponseEntity.badRequest().body(Error.errorResponse("User does not exist"));        }        // Check if room exists        RoomModel room = roomRepository.findById(roomId).orElse(null);        if (room == null) {            return ResponseEntity.badRequest().body(Error.errorResponse("Room does not exist"));        }        if (dateError) {            return ResponseEntity.badRequest().body(Error.errorResponse("Invalid date/time"));        }        if (timeFrom.after(timeTo)) {            return ResponseEntity.badRequest().body(Error.errorResponse("Invalid date/time"));        }        // Check if date day is in the past        Date currentDate = new Date();        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");        try {            currentDate = dateFormat.parse(dateFormat.format(currentDate));        } catch (ParseException e) {            throw new RuntimeException(e);        }        if (dateOfBooking.before(currentDate)) {            return ResponseEntity.badRequest().body(Error.errorResponse("Invalid date/time"));        }        Date timeFromParse = timeFrom;        Date timeToParse = timeTo;        // Add the time to the date and check if it is in the past        Calendar dateCalendar = Calendar.getInstance();        dateCalendar.setTime(dateOfBooking);        Calendar timeFromCalendar = Calendar.getInstance();        timeFromCalendar.setTime(timeFromParse);        dateCalendar.set(Calendar.HOUR_OF_DAY, timeFromCalendar.get(Calendar.HOUR_OF_DAY));        dateCalendar.set(Calendar.MINUTE, timeFromCalendar.get(Calendar.MINUTE));        dateCalendar.set(Calendar.SECOND, timeFromCalendar.get(Calendar.SECOND));        dateCalendar.set(Calendar.MILLISECOND, timeFromCalendar.get(Calendar.MILLISECOND));        Date timeFromDate = dateCalendar.getTime();// Repeat the same for timeToParse        Calendar timeToCalendar = Calendar.getInstance();        timeToCalendar.setTime(timeToParse);        dateCalendar.set(Calendar.HOUR_OF_DAY, timeToCalendar.get(Calendar.HOUR_OF_DAY));        dateCalendar.set(Calendar.MINUTE, timeToCalendar.get(Calendar.MINUTE));        dateCalendar.set(Calendar.SECOND, timeToCalendar.get(Calendar.SECOND));        dateCalendar.set(Calendar.MILLISECOND, timeToCalendar.get(Calendar.MILLISECOND));        Date timeToDate = dateCalendar.getTime();        if (timeFromDate.before(new Date()) || timeToDate.before(new Date())) {            return ResponseEntity.badRequest().body(Error.errorResponse("Invalid date/time"));        }        // Check if room is available        BookingModel existingBooking1 = bookingRepository.findByRoomIdAndDateOfBookingAndTimeFromLessThanEqualAndTimeToGreaterThanEqual(roomId, dateOfBooking, timeTo, timeTo);        BookingModel existingBooking2 = bookingRepository.findByRoomIdAndDateOfBookingAndTimeFromGreaterThanEqualAndTimeToLessThanEqual(roomId, dateOfBooking, timeFrom, timeTo);        BookingModel existingBooking3 = bookingRepository.findByRoomIdAndDateOfBookingAndTimeFromLessThanEqualAndTimeToGreaterThanEqual(roomId, dateOfBooking, timeFrom, timeFrom);        if (existingBooking1 != null || existingBooking2 != null || existingBooking3 != null) {            return ResponseEntity.badRequest().body(Error.errorResponse("Room unavailable"));        }        BookingModel booking = new BookingModel();        booking.setUser(user);        booking.setRoom(room);        booking.setTimeFrom(timeFrom);        booking.setDateOfBooking(dateOfBooking);        booking.setTimeTo(timeTo);        booking.setPurpose(purpose);        bookingRepository.save(booking);        return ResponseEntity.ok("Booking created successfully");    }    public ResponseEntity<Object> getBookingsByUserId(int userId) {        UserModel user = userRepository.findById(userId).orElse(null);        if (user == null) {            Map<String, Object> error = Map.of("Error", "User does not exist");            return ResponseEntity.badRequest().body(error);        }        List<BookingModel> allBookings = bookingRepository.findAllByUserId(userId);        ArrayList<Map<String, Object>> allBookingsMap = new ArrayList<>();        for (BookingModel booking : allBookings) {            allBookingsMap.add(UserService.convertBookingModelToMap(booking));        }        return ResponseEntity.ok(allBookingsMap);    }    public ResponseEntity<Object> deleteBooking(int bookingId) {        BookingModel booking = bookingRepository.findById(bookingId).orElse(null);        if (booking == null) {            return ResponseEntity.badRequest().body(Error.errorResponse("Booking does not exist"));        }        bookingRepository.delete(booking);        return ResponseEntity.ok("Booking deleted successfully");    }    public ResponseEntity<Object> updateBooking(int bookingId, Map<String, String> bookingDetails, boolean dateError) {        BookingModel booking = bookingRepository.findById(bookingId).orElse(null);        int userId = Integer.parseInt(bookingDetails.get("userID"));        UserModel user = userRepository.findById(userId).orElse(null);        if (user == null) {            Map<String, Object> error = Error.errorResponse("User does not exist");            return ResponseEntity.badRequest().body(error);        }        int roomId = Integer.parseInt(bookingDetails.get("roomID"));        RoomModel room = roomRepository.findById(roomId).orElse(null);        if (room == null) {            Map<String, Object> error = Error.errorResponse("Room does not exist");            return ResponseEntity.badRequest().body(error            );        }        if (booking == null) {            Map<String, Object> error = Error.errorResponse("Booking does not exist");            return ResponseEntity.badRequest().body(error            );        }        String purpose = bookingDetails.get("purpose");        if (purpose != null) {            booking.setPurpose(purpose);        }        try {            String timeFrom = bookingDetails.get("timeFrom");            if (timeFrom != null || bookingDetails.get("timeTo") != null || bookingDetails.get("dateOfBooking") != null) {                SimpleDateFormat timeFormat = new SimpleDateFormat("HH:mm:ss");                Date timeFromParse = timeFormat.parse(timeFrom);                Date timeToParse = timeFormat.parse(bookingDetails.get("timeTo"));                booking.setTimeFrom(timeFormat.parse(timeFrom));                String timeTo = bookingDetails.get("timeTo");                booking.setTimeTo(timeFormat.parse(timeTo));                System.out.println("reached here");                String dateOfBooking = bookingDetails.get("dateOfBooking");                SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");                Date dateOfBookingParse = dateFormat.parse(dateOfBooking);                booking.setDateOfBooking(dateFormat.parse(dateOfBooking));                Calendar dateCalendar = Calendar.getInstance();                dateCalendar.setTime(dateOfBookingParse);                Calendar timeFromCalendar = Calendar.getInstance();                timeFromCalendar.setTime(timeFromParse);                dateCalendar.set(Calendar.HOUR_OF_DAY, timeFromCalendar.get(Calendar.HOUR_OF_DAY));                dateCalendar.set(Calendar.MINUTE, timeFromCalendar.get(Calendar.MINUTE));                dateCalendar.set(Calendar.SECOND, timeFromCalendar.get(Calendar.SECOND));                dateCalendar.set(Calendar.MILLISECOND, timeFromCalendar.get(Calendar.MILLISECOND));                Date timeFromDate = dateCalendar.getTime();// Repeat the same for timeToParse                Calendar timeToCalendar = Calendar.getInstance();                timeToCalendar.setTime(timeToParse);                dateCalendar.set(Calendar.HOUR_OF_DAY, timeToCalendar.get(Calendar.HOUR_OF_DAY));                dateCalendar.set(Calendar.MINUTE, timeToCalendar.get(Calendar.MINUTE));                dateCalendar.set(Calendar.SECOND, timeToCalendar.get(Calendar.SECOND));                dateCalendar.set(Calendar.MILLISECOND, timeToCalendar.get(Calendar.MILLISECOND));                Date timeToDate = dateCalendar.getTime();                if (timeFromDate.before(new Date()) || timeToDate.before(new Date())) {                    return ResponseEntity.badRequest().body(Error.errorResponse("Invalid date/time"));                }                System.out.println("reached here");                // Check if room is available                BookingModel existingBooking1 = bookingRepository.findByRoomIdAndDateOfBookingAndTimeFromLessThanEqualAndTimeToGreaterThanEqual(roomId, dateOfBookingParse, timeToParse, timeToParse);                BookingModel existingBooking2 = bookingRepository.findByRoomIdAndDateOfBookingAndTimeFromGreaterThanEqualAndTimeToLessThanEqual(roomId, dateOfBookingParse, timeFromParse, timeToParse);                BookingModel existingBooking3 = bookingRepository.findByRoomIdAndDateOfBookingAndTimeFromLessThanEqualAndTimeToGreaterThanEqual(roomId, dateOfBookingParse, timeFromParse, timeFromParse);                if (existingBooking1 != null || existingBooking2 != null || existingBooking3 != null) {                    return ResponseEntity.badRequest().body(Error.errorResponse("Room unavailable"));                }                booking.setUser(user);                bookingRepository.save(booking);                return ResponseEntity.ok("Booking updated successfully");            }        } catch (Exception e) {            Map<String, Object> error = Error.errorResponse("Invalid date/time");            return ResponseEntity.badRequest().body(error);        }        booking.setUser(user);        bookingRepository.save(booking);        return ResponseEntity.ok("Booking updated successfully");    }}